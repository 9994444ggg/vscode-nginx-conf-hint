{
  "ngx.socket.udp": {
    "description": "创建并返回一个 UDP 或 datagram 的 unix 域套接字对象",
    "prefix": "ngx.socket.udp",
    "body": [
      "local udpsock = ngx.socket.udp()"
    ]
  },
  "udpsock:setpeername": {
    "description": "尝试将UDP套接字对象连接到远程服务器或数据报unix域套接字文件",
    "prefix": "ngx.socket.udp:setpeername",
    "body": [
      "local ok, err = $udpsock:setpeername($host, $port)"
    ]
  },
  "udpsock:send": {
    "description": "发送当前UDP或datagram unix域套接字对象的数据。",
    "prefix": "ngx.socket.udp:send",
    "body": [
      "local ok, err = $udpsock:send($data)"
    ]
  },
  "udpsock:receive": {
    "description": "接收来自UDP或datagram unix域套接字对象的数据",
    "prefix": "ngx.socket.udp:receive",
    "body": [
      "local data, err = $udpsock:receive()"
    ]
  },
  "udpsock:close": {
    "description": "关闭当前的UDP或datagram unix域套接字。",
    "prefix": "ngx.socket.udp:close",
    "body": [
      "local ok, err = $udpsock:close()"
    ]
  }, 
  "udpsock:settimeout": {
    "description": "为后续的套接字操作设置以毫秒为单位的超时值",
    "prefix": "ngx.socket.udp:settimeout",
    "body": [
      "$udpsock:settimeout($time)"
    ]
  }, 
  "ngx.socket.tcp": {
    "description": "创建并返回一个TCP或面向流的unix域套接字对象",
    "prefix": "ngx.socket.tcp",
    "body": [
      "local tcpsock = ngx.socket.tcp()"
    ]
  },
  "tcpsock:connect": {
    "description": "尝试将TCP套接字对象连接到远程服务器或流unix域套接字文件而不阻塞。",
    "prefix": "ngx.socket.tcp:connect",
    "body": [
      "local ok, err = $tcpsock:connect($host, $port, $options_table?)"
    ]
  },
  "tcpsock:sslhandshake": {
    "description": "SSL/TLS握手是否与当前已建立的连接有关。",
    "prefix": "ngx.socket.tcp:sslhandshake",
    "body": [
      "local session, err = $tcpsock:sslhandshake($reused_session?, $server_name?, $ssl_verify?, $send_status_req?)"
    ]
  },
  "tcpsock:send": {
    "description": "在不阻塞当前TCP或Unix域套接字连接的情况下发送数据。",
    "prefix": "ngx.socket.tcp:send",
    "body": [
      "local bytes, err = $tcpsock:send($data)"
    ]
  },
  "tcpsock:receive": {
    "description": "根据读取模式或大小从连接的套接字接收数据",
    "prefix": "ngx.socket.tcp:receive",
    "body": [
      "local data, err, partial = $tcpsock:receive($size)"
    ]
  },
  "tcpsock:receiveuntil": {
    "description": "该方法返回一个迭代器Lua函数，该函数可以调用该函数来读取数据流，直到它看到指定的模式或出现错误。",
    "prefix": "ngx.socket.tcp:receiveuntil",
    "body": [
      "local iterator = $tcpsock:receiveuntil($pattern, $options?)"
    ]
  },
  "tcpsock:close": {
    "description": "关闭当前的TCP或流unix域套接字。",
    "prefix": "ngx.socket.tcp:close",
    "body": [
      "local ok, err = $tcpsock:close()"
    ]
  },
  "tcpsock:settimeout": {
    "description": "为后续的套接字操作设置以毫秒为单位的超时值",
    "prefix": "ngx.socket.tcp:settimeout",
    "body": [
      "$tcpsock:settimeout($time)"
    ]
  },
  "tcpsock:settimeouts": {
    "description": "分别设置套接字的连接、发送、读取的超时时间，以毫秒为单位",
    "prefix": "ngx.socket.tcp:settimeouts",
    "body": [
      "$tcpsock:settimeouts($connect_timeout, $send_timeout, $read_timeout)"
    ]
  },
  "tcpsock:setoption": {
    "description": "这个函数添加到LuaSocket API兼容性，现在什么也不做。它的功能将在未来实现",
    "prefix": "ngx.socket.tcp:setoption",
    "body": [
      "$tcpsock:setoption($option, $value?)"
    ]
  },
  "tcpsock:setkeepalive": {
    "description": "将当前套接字的连接立即插入到cosocket内置的连接池中，并使其保持存活，直到其他连接方法调用请求或相关的最大空闲超时过期。",
    "prefix": "ngx.socket.tcp:setkeepalive",
    "body": [
      "local ok, err = $tcpsock:setkeepalive($timeout?, $size?)"
    ]
  },
  "tcpsock:getreusedtimes": {
    "description": "此方法返回当前连接的(成功)重用时间。如果出现错误，它返回nil和描述错误的字符串。",
    "prefix": "ngx.socket.tcp:getreusedtimes",
    "body": [
      "local  count, err = $tcpsock:getreusedtimes()"
    ]
  },
  "ngx.socket.connect": {
    "description": "这个函数是结合ngx.socket.tcp()和connect()方法调用的快捷方式。",
    "prefix": "ngx.socket.connect",
    "body": [
      "local  tcpsock, err = ngx.socket.connect($host, $port)"
    ]
  }                             

}