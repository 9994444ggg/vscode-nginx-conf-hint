[
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_capture_error_log size</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_capture_error_log ;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Enables a buffer of the specified <code>size</code> for capturing all the nginx error log message data (not just those produced\nby this module or the nginx http subsystem, but everything) without touching files or disks.</p><p>You can use units like <code>k</code> and <code>m</code> in the <code>size</code> value, as in</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">lua_capture_error_log</span> 100k;</pre></div><p>As a rule of thumb, a 4KB buffer can usually hold about 20 typical error log messages. So do the maths!</p><p>This buffer never grows. If it is full, new error log messages will replace the oldest ones in the buffer.</p><p>The size of the buffer must be bigger than the maximum length of a single error log message (which is 4K in OpenResty and 2K in stock NGINX).</p><p>You can read the messages in the buffer on the Lua land via the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#get_logs\">get_logs()</a>\nfunction of the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme\">ngx.errlog</a>\nmodule of the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#readme\">lua-resty-core</a>\nlibrary. This Lua API function will return the captured error log messages and\nalso remove these already read from the global capturing buffer, making room\nfor any new error log data. For this reason, the user should not configure this\nbuffer to be too big if the user read the buffered error log data fast enough.</p><p>Note that the log level specified in the standard <a href=\"http://nginx.org/r/error_log\" rel=\"nofollow\">error_log</a> directive\n<em>does</em> have effect on this capturing facility. It only captures log\nmessages of a level no lower than the specified log level in the <a href=\"http://nginx.org/r/error_log\" rel=\"nofollow\">error_log</a> directive.\nThe user can still choose to set an even higher filtering log level on the fly via the Lua API function\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/errlog.md#set_filter_level\">errlog.set_filter_level</a>.\nSo it is more flexible than the static <a href=\"http://nginx.org/r/error_log\" rel=\"nofollow\">error_log</a> directive.</p><p>It is worth noting that there is no way to capture the debugging logs\nwithout building OpenResty or NGINX with the <code>./configure</code>\noption <code>--with-debug</code>. And enabling debugging logs is\nstrongly discouraged in production builds due to high overhead.</p><p>This directive was first introduced in the <code>v0.10.9</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_capture_error_log",
    "name": "lua_capture_error_log"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_use_default_type on | off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_use_default_type on</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Specifies whether to use the MIME type specified by the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#default_type\" rel=\"nofollow\">default_type</a> directive for the default value of the <code>Content-Type</code> response header. Deactivate this directive if a default <code>Content-Type</code> response header for Lua request handlers is not desired.</p><p>This directive is turned on by default.</p><p>This directive was first introduced in the <code>v0.9.1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_use_default_type",
    "name": "lua_use_default_type"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_malloc_trim <request-count></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_malloc_trim 1000</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Asks the underlying <code>libc</code> runtime library to release its cached free memory back to the operating system every\n<code>N</code> requests processed by the NGINX core. By default, <code>N</code> is 1000. You can configure the request count\nby using your own numbers. Smaller numbers mean more frequent releases, which may introduce higher CPU time consumption and\nsmaller memory footprint while larger numbers usually lead to less CPU time overhead and relatively larger memory footprint.\nJust tune the number for your own use cases.</p><p>Configuring the argument to <code>0</code> essentially turns off the periodical memory trimming altogether.</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">lua_malloc_trim</span> 0;  <span class=\"pl-c\"># turn off trimming completely</span></pre></div><p>The current implementation uses an NGINX log phase handler to do the request counting. So the appearance of the\n<a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#log_subrequest\" rel=\"nofollow\">log_subrequest on</a> directives in <code>nginx.conf</code>\nmay make the counting faster when subrequests are involved. By default, only &quot;main requests&quot; count.</p><p>Note that this directive does <em>not</em> affect the memory allocated by LuaJIT&apos;s own allocator based on the <code>mmap</code>\nsystem call.</p><p>This directive was first introduced in the <code>v0.10.7</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_malloc_trim",
    "name": "lua_malloc_trim"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_code_cache on | off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_code_cache on</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Enables or disables the Lua code cache for Lua code in <code>*_by_lua_file</code> directives (like <a href=\"#set_by_lua_file\">set_by_lua_file</a> and\n<a href=\"#content_by_lua_file\">content_by_lua_file</a>) and Lua modules.</p><p>When turning off, every request served by ngx_lua will run in a separate Lua VM instance, starting from the <code>0.9.3</code> release. So the Lua files referenced in <a href=\"#set_by_lua_file\">set_by_lua_file</a>,\n<a href=\"#content_by_lua_file\">content_by_lua_file</a>, <a href=\"#access_by_lua_file\">access_by_lua_file</a>,\nand etc will not be cached\nand all Lua modules used will be loaded from scratch. With this in place, developers can adopt an edit-and-refresh approach.</p><p>Please note however, that Lua code written inlined within nginx.conf\nsuch as those specified by <a href=\"#set_by_lua\">set_by_lua</a>, <a href=\"#content_by_lua\">content_by_lua</a>,\n<a href=\"#access_by_lua\">access_by_lua</a>, and <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> will not be updated when you edit the inlined Lua code in your <code>nginx.conf</code> file because only the Nginx config file parser can correctly parse the <code>nginx.conf</code>\nfile and the only way is to reload the config file\nby sending a <code>HUP</code> signal or just to restart Nginx.</p><p>Even when the code cache is enabled, Lua files which are loaded by <code>dofile</code> or <code>loadfile</code>\nin *_by_lua_file cannot be cached (unless you cache the results yourself). Usually you can either use the <a href=\"#init_by_lua\">init_by_lua</a>\nor <a href=\"#init-by_lua_file\">init_by_lua_file</a> directives to load all such files or just make these Lua files true Lua modules\nand load them via <code>require</code>.</p><p>The ngx_lua module does not support the <code>stat</code> mode available with the\nApache <code>mod_lua</code> module (yet).</p><p>Disabling the Lua code cache is strongly\ndiscouraged for production use and should only be used during\ndevelopment as it has a significant negative impact on overall performance. For example, the performance of a &quot;hello world&quot; Lua example can drop by an order of magnitude after disabling the Lua code cache.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_code_cache",
    "name": "lua_code_cache"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_regex_cache_max_entries <num></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_regex_cache_max_entries 1024</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Specifies the maximum number of entries allowed in the worker process level compiled regex cache.</p><p>The regular expressions used in <a href=\"#ngxrematch\">ngx.re.match</a>, <a href=\"#ngxregmatch\">ngx.re.gmatch</a>, <a href=\"#ngxresub\">ngx.re.sub</a>, and <a href=\"#ngxregsub\">ngx.re.gsub</a> will be cached within this cache if the regex option <code>o</code> (i.e., compile-once flag) is specified.</p><p>The default number of entries allowed is 1024 and when this limit is reached, new regular expressions will not be cached (as if the <code>o</code> option was not specified) and there will be one, and only one, warning in the <code>error.log</code> file:</p><pre><code>2011/08/27 23:18:26 [warn] 31997#0: *1 lua exceeding regex cache max entries (1024), ...\n</code></pre><p>If you are using the <code>ngx.re.*</code> implementation of <a href=\"https://github.com/openresty/lua-resty-core\">lua-resty-core</a> by loading the <code>resty.core.regex</code> module (or just the <code>resty.core</code> module), then an LRU cache is used for the regex cache being used here.</p><p>Do not activate the <code>o</code> option for regular expressions (and/or <code>replace</code> string arguments for <a href=\"#ngxresub\">ngx.re.sub</a> and <a href=\"#ngxregsub\">ngx.re.gsub</a>) that are generated <em>on the fly</em> and give rise to infinite variations to avoid hitting the specified limit.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_regex_cache_max_entries",
    "name": "lua_regex_cache_max_entries"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_regex_match_limit <num></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_regex_match_limit 0</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Specifies the &quot;match limit&quot; used by the PCRE library when executing the <a href=\"#ngxrematch\">ngx.re API</a>. To quote the PCRE manpage, &quot;the limit ... has the effect of limiting the amount of backtracking that can take place.&quot;</p><p>When the limit is hit, the error string &quot;pcre_exec() failed: -8&quot; will be returned by the <a href=\"#ngxrematch\">ngx.re API</a> functions on the Lua land.</p><p>When setting the limit to 0, the default &quot;match limit&quot; when compiling the PCRE library is used. And this is the default value of this directive.</p><p>This directive was first introduced in the <code>v0.8.5</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_regex_match_limit",
    "name": "lua_regex_match_limit"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_package_path <lua-style-path-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>The content of LUA_PATH environment variable or Lua's compiled-in defaults.</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Sets the Lua module search path used by scripts specified by <a href=\"#set_by_lua\">set_by_lua</a>,\n<a href=\"#content_by_lua\">content_by_lua</a> and others. The path string is in standard Lua path form, and <code>;;</code>\ncan be used to stand for the original search paths.</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_package_path",
    "name": "lua_package_path"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_package_cpath <lua-style-cpath-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>The content of LUA_CPATH environment variable or Lua's compiled-in defaults.</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Sets the Lua C-module search path used by scripts specified by <a href=\"#set_by_lua\">set_by_lua</a>,\n<a href=\"#content_by_lua\">content_by_lua</a> and others. The cpath string is in standard Lua cpath form, and <code>;;</code>\ncan be used to stand for the original cpath.</p><p>As from the <code>v0.5.0rc29</code> release, the special notation <code>$prefix</code> or <code>${prefix}</code> can be used in the search path string to indicate the path of the <code>server prefix</code> usually determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_package_cpath",
    "name": "lua_package_cpath"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>init_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#init_by_lua_block\">init_by_lua_block</a> directive instead.</p><p>Runs the Lua code specified by the argument <code>&lt;lua-script-str&gt;</code> on the global Lua VM level when the Nginx master process (if any) is loading the Nginx config file.</p><p>When Nginx receives the <code>HUP</code> signal and starts reloading the config file, the Lua VM will also be re-created and <code>init_by_lua</code> will run again on the new Lua VM. In case that the <a href=\"#lua_code_cache\">lua_code_cache</a> directive is turned off (default on), the <code>init_by_lua</code> handler will run upon every request because in this special mode a standalone Lua VM is always created for each request.</p><p>Usually you can pre-load Lua modules at server start-up by means of this hook and take advantage of modern operating systems&apos; copy-on-write (COW) optimization. Here is an example for pre-loading Lua modules:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-c\"># this runs before forking out nginx worker processes:</span>\n <span class=\"pl-k\">init_by_lua_block</span> { require <span class=\"pl-s\">&quot;cjson&quot;</span> }\n\n <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">location</span> <span class=\"pl-en\">= /api </span>{\n         <span class=\"pl-k\">content_by_lua_block</span> {\n             -- <span class=\"pl-k\">the</span> following require() will just  return\n             -- <span class=\"pl-k\">the</span> alrady loaded module from package.loaded:\n             ngx.say(<span class=\"pl-k\">require</span> <span class=\"pl-s\">&quot;cjson&quot;</span>.encode{dog = 5, cat = 6})\n         }\n     }\n }</pre></div><p>You can also initialize the <a href=\"#lua_shared_dict\">lua_shared_dict</a> shm storage at this phase. Here is an example for this:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">lua_shared_dict</span> dogs <span class=\"pl-c1\">1m</span>;\n\n <span class=\"pl-k\">init_by_lua_block</span> {\n     <span class=\"pl-k\">local</span> dogs = ngx.shared.dogs;\n     dogs:<span class=\"pl-k\">set</span>(<span class=\"pl-s\">&quot;Tom&quot;</span>, 56)\n }\n\n server {\n     location = /api {\n         content_by_lua_block {\n             local dogs = ngx.shared.dogs;\n             ngx.say(dogs:get(&quot;Tom&quot;))\n         }\n     }\n }</pre></div><p>But note that, the <a href=\"#lua_shared_dict\">lua_shared_dict</a>&apos;s shm storage will not be cleared through a config reload (via the <code>HUP</code> signal, for example). So if you do <em>not</em> want to re-initialize the shm storage in your <code>init_by_lua</code> code in this case, then you just need to set a custom flag in the shm storage and always check the flag in your <code>init_by_lua</code> code.</p><p>Because the Lua code in this context runs before Nginx forks its worker processes (if any), data or code loaded here will enjoy the <a href=\"http://en.wikipedia.org/wiki/Copy-on-write\" rel=\"nofollow\">Copy-on-write (COW)</a> feature provided by many operating systems among all the worker processes, thus saving a lot of memory.</p><p>Do <em>not</em> initialize your own Lua global variables in this context because use of Lua global variables have performance penalties and can lead to global namespace pollution (see the <a href=\"#lua-variable-scope\">Lua Variable Scope</a> section for more details). The recommended way is to use proper <a href=\"http://www.lua.org/manual/5.1/manual.html#5.3\" rel=\"nofollow\">Lua module</a> files (but do not use the standard Lua function <a href=\"http://www.lua.org/manual/5.1/manual.html#pdf-module\" rel=\"nofollow\">module()</a> to define Lua modules because it pollutes the global namespace as well) and call <a href=\"http://www.lua.org/manual/5.1/manual.html#pdf-require\" rel=\"nofollow\">require()</a> to load your own module files in <code>init_by_lua</code> or other contexts (<a href=\"http://www.lua.org/manual/5.1/manual.html#pdf-require\" rel=\"nofollow\">require()</a> does cache the loaded Lua modules in the global <code>package.loaded</code> table in the Lua registry so your modules will only loaded once for the whole Lua VM instance).</p><p>Only a small set of the <a href=\"#nginx-api-for-lua\">Nginx API for Lua</a> is supported in this context:</p><ul>\n<li>Logging APIs: <a href=\"#ngxlog\">ngx.log</a> and <a href=\"#print\">print</a>,</li>\n<li>Shared Dictionary API: <a href=\"#ngxshareddict\">ngx.shared.DICT</a>.</li>\n</ul><p>More Nginx APIs for Lua may be supported in this context upon future user requests.</p><p>Basically you can safely use Lua libraries that do blocking I/O in this very context because blocking the master process during server start-up is completely okay. Even the Nginx core does blocking I/O (at least on resolving upstream&apos;s host names) at the configure-loading phase.</p><p>You should be very careful about potential security vulnerabilities in your Lua code registered in this context because the Nginx master process is often run under the <code>root</code> account.</p><p>This directive was first introduced in the <code>v0.5.5</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#init_by_lua",
    "name": "init_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>init_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#init_by_lua\">init_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">init_by_lua_block</span> {\n     print(&quot;<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\"> }</span></pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#init_by_lua_block",
    "name": "init_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>init_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#init_by_lua\">init_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code or <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.5</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#init_by_lua_file",
    "name": "init_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>init_worker_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_worker_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#init_worker_by_lua_block\">init_worker_by_lua_block</a> directive instead.</p><p>Runs the specified Lua code upon every Nginx worker process&apos;s startup when the master process is enabled. When the master process is disabled, this hook will just run after <a href=\"#init_by_lua\">init_by_lua*</a>.</p><p>This hook is often used to create per-worker reoccurring timers (via the <a href=\"#ngxtimerat\">ngx.timer.at</a> Lua API), either for backend health-check or other timed routine work. Below is an example,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">init_worker_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">     local delay = 3  -- in seconds</span>\n<span class=\"pl-s\">     local new_timer = ngx.timer.at</span>\n<span class=\"pl-s\">     local log = ngx.log</span>\n<span class=\"pl-s\">     local ERR = ngx.ERR</span>\n<span class=\"pl-s\">     local check</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     check = function(premature)</span>\n<span class=\"pl-s\">         if not premature then</span>\n<span class=\"pl-s\">             -- do the health check or other routine work</span>\n<span class=\"pl-s\">             local ok, err = new_timer(delay, check)</span>\n<span class=\"pl-s\">             if not ok then</span>\n<span class=\"pl-s\">                 log(ERR, &quot;failed to create timer: &quot;, err)</span>\n<span class=\"pl-s\">                 return</span>\n<span class=\"pl-s\">             end</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\">     end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     local hdl, err = new_timer(delay, check)</span>\n<span class=\"pl-s\">     if not hdl then</span>\n<span class=\"pl-s\">         log(ERR, &quot;failed to create timer: &quot;, err)</span>\n<span class=\"pl-s\">         return</span>\n<span class=\"pl-s\">     end</span>\n<span class=\"pl-s\"> &apos;</span>;</pre></div><p>This directive was first introduced in the <code>v0.9.5</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#init_worker_by_lua",
    "name": "init_worker_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>init_worker_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_worker_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#init_worker_by_lua\">init_worker_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">init_worker_by_lua_block</span> {\n     print(&quot;<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\"> }</span></pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#init_worker_by_lua_block",
    "name": "init_worker_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>init_worker_by_lua_file <lua-file-path></strong></code><br></td></tr><tr><th>Default:</th><td><pre>init_worker_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Similar to <a href=\"#init_worker_by_lua\">init_worker_by_lua</a>, but accepts the file path to a Lua source file or Lua bytecode file.</p><p>This directive was first introduced in the <code>v0.9.5</code> release.</p><p>This hook no longer runs in the cache manager and cache loader processes since the <code>v0.10.12</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#init_worker_by_lua_file",
    "name": "init_worker_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>set_by_lua $res <lua-script-str> [$arg1 $arg2 ...]</strong></code><br></td></tr><tr><th>Default:</th><td><pre>set_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>server</code></br><code>server if</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#set_by_lua_block\">set_by_lua_block</a> directive instead.</p><p>Executes code specified in <code>&lt;lua-script-str&gt;</code> with optional input arguments <code>$arg1 $arg2 ...</code>, and returns string output to <code>$res</code>.\nThe code in <code>&lt;lua-script-str&gt;</code> can make <a href=\"#nginx-api-for-lua\">API calls</a> and can retrieve input arguments from the <code>ngx.arg</code> table (index starts from <code>1</code> and increases sequentially).</p><p>This directive is designed to execute short, fast running code blocks as the Nginx event loop is blocked during code execution. Time consuming code sequences should therefore be avoided.</p><p>This directive is implemented by injecting custom commands into the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>&apos;s command list. Because <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a> does not support nonblocking I/O in its commands, Lua APIs requiring yielding the current Lua &quot;light thread&quot; cannot work in this directive.</p><p>At least the following API functions are currently disabled within the context of <code>set_by_lua</code>:</p><ul>\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxexit\">ngx.exit</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n<li>Sleeping API function <a href=\"#ngxsleep\">ngx.sleep</a>.</li>\n</ul><p>In addition, note that this directive can only write out a value to a single Nginx variable at\na time. However, a workaround is possible using the <a href=\"#ngxvarvariable\">ngx.var.VARIABLE</a> interface.</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$diff</span> <span class=\"pl-s\">&apos;&apos;</span>; <span class=\"pl-c\"># we have to predefine the $diff variable here</span>\n\n     <span class=\"pl-k\">set_by_lua</span> <span class=\"pl-smi\">$sum</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">         local a = 32</span>\n<span class=\"pl-s\">         local b = 56</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         ngx.var.diff = a - b;  -- write to <span class=\"pl-smi\">$diff</span> directly</span>\n<span class=\"pl-s\">         return a + b;          -- return the <span class=\"pl-smi\">$sum</span> value normally</span>\n<span class=\"pl-s\">     &apos;</span>;\n\n     <span class=\"pl-k\">echo</span> <span class=\"pl-s\">&quot;sum = <span class=\"pl-smi\">$sum</span>, diff = <span class=\"pl-smi\">$diff</span>&quot;</span>;\n }</pre></div><p>This directive can be freely mixed with all directives of the <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>, <a href=\"http://github.com/openresty/set-misc-nginx-module\">set-misc-nginx-module</a>, and <a href=\"http://github.com/openresty/array-var-nginx-module\">array-var-nginx-module</a> modules. All of these directives will run in the same order as they appear in the config file.</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$foo</span> <span class=\"pl-s\">32</span>;\n <span class=\"pl-k\">set_by_lua</span> <span class=\"pl-smi\">$bar</span> <span class=\"pl-s\">&apos;return tonumber(ngx.var.foo) + 1&apos;</span>;\n <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$baz</span> <span class=\"pl-s\">&quot;bar: <span class=\"pl-smi\">$bar</span>&quot;</span>;  <span class=\"pl-c\"># $baz == &quot;bar: 33&quot;</span></pre></div><p>As from the <code>v0.5.0rc29</code> release, Nginx variable interpolation is disabled in the <code>&lt;lua-script-str&gt;</code> argument of this directive and therefore, the dollar sign character (<code>$</code>) can be used directly.</p><p>This directive requires the <a href=\"https://github.com/simplresty/ngx_devel_kit\">ngx_devel_kit</a> module.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#set_by_lua",
    "name": "set_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>set_by_lua_block $res { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>set_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>server</code></br><code>server if</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#set_by_lua\">set_by_lua</a> directive except that</p><ol>\n<li>this directive inlines the Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping), and</li>\n<li>this directive does not support extra arguments after the Lua script as in <a href=\"#set_by_lua\">set_by_lua</a>.</li>\n</ol><p>For example,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">set_by_lua_block</span> <span class=\"pl-smi\">$res</span> { return <span class=\"pl-s\">32</span> + math.cos(32) }\n <span class=\"pl-c\"># $res now has the value &quot;32.834223360507&quot; or alike.</span></pre></div><p>No special escaping is required in the Lua code block.</p><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#set_by_lua_block",
    "name": "set_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>set_by_lua_file $res <path-to-lua-script-file> [$arg1 $arg2 ...]</strong></code><br></td></tr><tr><th>Default:</th><td><pre>set_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>server</code></br><code>server if</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#set_by_lua\">set_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variable interpolation is supported in the <code>&lt;path-to-lua-script-file&gt;</code> argument string of this directive. But special care must be taken for injection attacks.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by\nswitching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>This directive requires the <a href=\"https://github.com/simplresty/ngx_devel_kit\">ngx_devel_kit</a> module.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#set_by_lua_file",
    "name": "set_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>content_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>content_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#content_by_lua_block\">content_by_lua_block</a> directive instead.</p><p>Acts as a &quot;content handler&quot; and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.\nThe Lua code may make <a href=\"#nginx-api-for-lua\">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Do not use this directive and other content handler directives in the same location. For example, this directive and the <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_pass\" rel=\"nofollow\">proxy_pass</a> directive should not be used in the same location.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#content_by_lua",
    "name": "content_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>content_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>content_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#content_by_lua\">content_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">content_by_lua_block</span> {\n     ngx.say(&quot;<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\"> }</span></pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#content_by_lua_block",
    "name": "content_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>content_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>content_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#content_by_lua\">content_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by\nswitching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>Nginx variables are supported in the file path for dynamic dispatch, for example:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-c\"># CAUTION: contents in nginx var must be carefully filtered,</span>\n <span class=\"pl-c\"># otherwise there&apos;ll be great security risk!</span>\n <span class=\"pl-k\">location</span> ~ <span class=\"pl-sr\">^/app/([-_a-zA-Z0-9/]+) </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$path</span> <span class=\"pl-smi\">$1</span>;\n     <span class=\"pl-k\">content_by_lua_file</span> /path/to/lua/app/root/<span class=\"pl-smi\">$path</span>.lua;\n }</pre></div><p>But be very careful about malicious user inputs and always carefully validate or filter out the user-supplied path components.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#content_by_lua_file",
    "name": "content_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#rewrite_by_lua_block\">rewrite_by_lua_block</a> directive instead.</p><p>Acts as a rewrite phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.\nThe Lua code may make <a href=\"#nginx-api-for-lua\">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Note that this handler always runs <em>after</em> the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>. So the following will work as expected:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$a</span> <span class=\"pl-s\">12</span>; <span class=\"pl-c\"># create and initialize $a</span>\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$b</span> <span class=\"pl-s\">&quot;&quot;</span>; <span class=\"pl-c\"># create and initialize $b</span>\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">&apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;</span>;\n     <span class=\"pl-k\">echo</span> <span class=\"pl-s\">&quot;res = <span class=\"pl-smi\">$b</span>&quot;</span>;\n }</pre></div><p>because <code>set $a 12</code> and <code>set $b &quot;&quot;</code> run <em>before</em> <a href=\"#rewrite_by_lua\">rewrite_by_lua</a>.</p><p>On the other hand, the following will not work as expected:</p><div class=\"highlight highlight-source-nginx\"><pre> ?  <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n ?      <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$a</span> <span class=\"pl-s\">12</span>; <span class=\"pl-c\"># create and initialize $a</span>\n ?      <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$b</span> <span class=\"pl-s\">&apos;&apos;</span>; <span class=\"pl-c\"># create and initialize $b</span>\n ?      <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">&apos;ngx.var.b = tonumber(ngx.var.a) + 1&apos;</span>;\n ?      <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">$b</span> = <span class=\"pl-s\">&apos;13&apos;</span>) {\n ?         <span class=\"pl-k\">rewrite</span> <span class=\"pl-sr\">^ </span>/bar redirect;\n ?         <span class=\"pl-c1\">break</span>;\n ?      }\n ?\n ?      <span class=\"pl-k\">echo</span> <span class=\"pl-s\">&quot;res = <span class=\"pl-smi\">$b</span>&quot;</span>;\n ?  }</pre></div><p>because <code>if</code> runs <em>before</em> <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> even if it is placed after <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> in the config.</p><p>The right way of doing this is as follows:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$a</span> <span class=\"pl-s\">12</span>; <span class=\"pl-c\"># create and initialize $a</span>\n     <span class=\"pl-k\">set</span> <span class=\"pl-smi\">$b</span> <span class=\"pl-s\">&apos;&apos;</span>; <span class=\"pl-c\"># create and initialize $b</span>\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">         ngx.var.b = tonumber(ngx.var.a) + 1</span>\n<span class=\"pl-s\">         if tonumber(ngx.var.b) == 13 then</span>\n<span class=\"pl-s\">             return ngx.redirect(&quot;/bar&quot;);</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\">     &apos;</span>;\n\n     <span class=\"pl-k\">echo</span> <span class=\"pl-s\">&quot;res = <span class=\"pl-smi\">$b</span>&quot;</span>;\n }</pre></div><p>Note that the <a href=\"http://www.grid.net.ru/nginx/eval.en.html\" rel=\"nofollow\">ngx_eval</a> module can be approximated by using <a href=\"#rewrite_by_lua\">rewrite_by_lua</a>. For example,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">eval</span> <span class=\"pl-smi\">$res</span> {\n         <span class=\"pl-k\">proxy_pass</span> http://foo.com/check-spam;\n     }\n\n     <span class=\"pl-k\">if</span> (<span class=\"pl-smi\">$res</span> = <span class=\"pl-s\">&apos;spam&apos;</span>) {\n         <span class=\"pl-k\">rewrite</span> <span class=\"pl-sr\">^ </span>/terms-of-use.html redirect;\n     }\n\n     <span class=\"pl-k\">fastcgi_pass</span> ...;\n }</pre></div><p>can be implemented in ngx_lua as:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">= /check-spam </span>{\n     <span class=\"pl-k\">internal</span>;\n     <span class=\"pl-k\">proxy_pass</span> http://foo.com/check-spam;\n }\n\n <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">         local res = ngx.location.capture(&quot;/check-spam&quot;)</span>\n<span class=\"pl-s\">         if res.body == &quot;spam&quot; then</span>\n<span class=\"pl-s\">             return ngx.redirect(&quot;/terms-of-use.html&quot;)</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\">     &apos;</span>;\n\n     <span class=\"pl-k\">fastcgi_pass</span> ...;\n }</pre></div><p>Just as any other rewrite phase handlers, <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> also runs in subrequests.</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> handler, calling <a href=\"#ngxexit\">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p>If the <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html\" rel=\"nofollow\">ngx_http_rewrite_module</a>&apos;s <a href=\"http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#rewrite\" rel=\"nofollow\">rewrite</a> directive is used to change the URI and initiate location re-lookups (internal redirections), then any <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> or <a href=\"#rewrite_by_lua_file\">rewrite_by_lua_file</a> code sequences within the current location will not be executed. For example,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-k\">rewrite</span> <span class=\"pl-sr\">^ </span>/bar;\n     <span class=\"pl-k\">rewrite_by_lua</span> <span class=\"pl-s\">&apos;ngx.exit(503)&apos;</span>;\n }\n <span class=\"pl-k\">location</span> <span class=\"pl-en\">/bar </span>{\n     ...\n }</pre></div><p>Here the Lua code <code>ngx.exit(503)</code> will never run. This will be the case if <code>rewrite ^ /bar last</code> is used as this will similarly initiate an internal redirection. If the <code>break</code> modifier is used instead, there will be no internal redirection and the <code>rewrite_by_lua</code> code will be executed.</p><p>The <code>rewrite_by_lua</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href=\"#rewrite_by_lua_no_postpone\">rewrite_by_lua_no_postpone</a> is turned on.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#rewrite_by_lua",
    "name": "rewrite_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#rewrite_by_lua\">rewrite_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">rewrite_by_lua_block</span> {\n     do_something(&quot;hello, world!\\nhiya\\n&quot;)\n }</pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#rewrite_by_lua_block",
    "name": "rewrite_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#rewrite_by_lua\">rewrite_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached and the Nginx config must be reloaded each time the Lua source file is modified. The Lua code cache can be temporarily disabled during development by switching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid reloading Nginx.</p><p>The <code>rewrite_by_lua_file</code> code will always run at the end of the <code>rewrite</code> request-processing phase unless <a href=\"#rewrite_by_lua_no_postpone\">rewrite_by_lua_no_postpone</a> is turned on.</p><p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href=\"#content_by_lua_file\">content_by_lua_file</a>.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#rewrite_by_lua_file",
    "name": "rewrite_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#access_by_lua_block\">access_by_lua_block</a> directive instead.</p><p>Acts as an access phase handler and executes Lua code string specified in <code>&lt;lua-script-str&gt;</code> for every request.\nThe Lua code may make <a href=\"#nginx-api-for-lua\">API calls</a> and is executed as a new spawned coroutine in an independent global environment (i.e. a sandbox).</p><p>Note that this handler always runs <em>after</em> the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_access_module.html\" rel=\"nofollow\">ngx_http_access_module</a>. So the following will work as expected:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">deny</span>    <span class=\"pl-s\">192.168.1.1</span>;\n     <span class=\"pl-k\">allow</span>   <span class=\"pl-s\">192.168.1.0</span><span class=\"pl-c1\">/24</span>;\n     <span class=\"pl-k\">allow</span>   <span class=\"pl-s\">10.1.1.0</span><span class=\"pl-c1\">/16</span>;\n     <span class=\"pl-k\">deny</span>   <span class=\"pl-c1\"> all</span>;\n\n     <span class=\"pl-k\">access_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">         local res = ngx.location.capture(&quot;/mysql&quot;, { ... })</span>\n<span class=\"pl-s\">         ...</span>\n<span class=\"pl-s\">     &apos;</span>;\n\n     <span class=\"pl-c\"># proxy_pass/fastcgi_pass/...</span>\n }</pre></div><p>That is, if a client IP address is in the blacklist, it will be denied before the MySQL query for more complex authentication is executed by <a href=\"#access_by_lua\">access_by_lua</a>.</p><p>Note that the <a href=\"http://mdounin.ru/hg/ngx_http_auth_request_module/\" rel=\"nofollow\">ngx_auth_request</a> module can be approximated by using <a href=\"#access_by_lua\">access_by_lua</a>:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">auth_request</span> /auth;\n\n     <span class=\"pl-c\"># proxy_pass/fastcgi_pass/postgres_pass/...</span>\n }</pre></div><p>can be implemented in ngx_lua as:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">access_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">         local res = ngx.location.capture(&quot;/auth&quot;)</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         if res.status == ngx.HTTP_OK then</span>\n<span class=\"pl-s\">             return</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         if res.status == ngx.HTTP_FORBIDDEN then</span>\n<span class=\"pl-s\">             ngx.exit(res.status)</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</span>\n<span class=\"pl-s\">     &apos;</span>;\n\n     <span class=\"pl-c\"># proxy_pass/fastcgi_pass/postgres_pass/...</span>\n }</pre></div><p>As with other access phase handlers, <a href=\"#access_by_lua\">access_by_lua</a> will <em>not</em> run in subrequests.</p><p>Note that when calling <code>ngx.exit(ngx.OK)</code> within a <a href=\"#access_by_lua\">access_by_lua</a> handler, the nginx request processing control flow will still continue to the content handler. To terminate the current request from within a <a href=\"#access_by_lua\">access_by_lua</a> handler, calling <a href=\"#ngxexit\">ngx.exit</a> with status &gt;= 200 (<code>ngx.HTTP_OK</code>) and status &lt; 300 (<code>ngx.HTTP_SPECIAL_RESPONSE</code>) for successful quits and <code>ngx.exit(ngx.HTTP_INTERNAL_SERVER_ERROR)</code> (or its friends) for failures.</p><p>Starting from the <code>v0.9.20</code> release, you can use the <a href=\"#access_by_lua_no_postpone\">access_by_lua_no_postpone</a>\ndirective to control when to run this handler inside the &quot;access&quot; request-processing phase\nof NGINX.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#access_by_lua",
    "name": "access_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#access_by_lua\">access_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">access_by_lua_block</span> {\n     do_something(&quot;hello, world!\\nhiya\\n&quot;)\n }</pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#access_by_lua_block",
    "name": "access_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#access_by_lua\">access_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>Nginx variables can be used in the <code>&lt;path-to-lua-script-file&gt;</code> string to provide flexibility. This however carries some risks and is not ordinarily recommended.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>When the Lua code cache is turned on (by default), the user code is loaded once at the first request and cached\nand the Nginx config must be reloaded each time the Lua source file is modified.\nThe Lua code cache can be temporarily disabled during development by switching <a href=\"#lua_code_cache\">lua_code_cache</a> <code>off</code> in <code>nginx.conf</code> to avoid repeatedly reloading Nginx.</p><p>Nginx variables are supported in the file path for dynamic dispatch just as in <a href=\"#content_by_lua_file\">content_by_lua_file</a>.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#access_by_lua_file",
    "name": "access_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>header_filter_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>header_filter_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#header_filter_by_lua_block\">header_filter_by_lua_block</a> directive instead.</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output header filter.</p><p>Note that the following API functions are currently disabled within this context:</p><ul>\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxredirect\">ngx.redirect</a> and <a href=\"#ngxexec\">ngx.exec</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n</ul><p>Here is an example of overriding a response header (or adding one if absent) in our Lua header filter:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">proxy_pass</span> http://mybackend;\n     <span class=\"pl-k\">header_filter_by_lua</span> <span class=\"pl-s\">&apos;ngx.header.Foo = &quot;blah&quot;&apos;</span>;\n }</pre></div><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#header_filter_by_lua",
    "name": "header_filter_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>header_filter_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>header_filter_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#header_filter_by_lua\">header_filter_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">header_filter_by_lua_block</span> {\n     ngx.header[&quot;content-length&quot;] = <span class=\"pl-k\">nil</span>\n }</pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#header_filter_by_lua_block",
    "name": "header_filter_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>header_filter_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>header_filter_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#header_filter_by_lua\">header_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.2.1rc20</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#header_filter_by_lua_file",
    "name": "header_filter_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>body_filter_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>body_filter_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#body_filter_by_lua_block\">body_filter_by_lua_block</a> directive instead.</p><p>Uses Lua code specified in <code>&lt;lua-script-str&gt;</code> to define an output body filter.</p><p>The input data chunk is passed via <a href=\"#ngxarg\">ngx.arg</a>[1] (as a Lua string value) and the &quot;eof&quot; flag indicating the end of the response body data stream is passed via <a href=\"#ngxarg\">ngx.arg</a>[2] (as a Lua boolean value).</p><p>Behind the scene, the &quot;eof&quot; flag is just the <code>last_buf</code> (for main requests) or <code>last_in_chain</code> (for subrequests) flag of the Nginx chain link buffers. (Before the <code>v0.7.14</code> release, the &quot;eof&quot; flag does not work at all in subrequests.)</p><p>The output data stream can be aborted immediately by running the following Lua statement:</p><div class=\"highlight highlight-source-lua\"><pre> <span class=\"pl-k\">return</span> ngx.<span class=\"pl-smi\">ERROR</span></pre></div><p>This will truncate the response body and usually result in incomplete and also invalid responses.</p><p>The Lua code can pass its own modified version of the input data chunk to the downstream Nginx output body filters by overriding <a href=\"#ngxarg\">ngx.arg</a>[1] with a Lua string or a Lua table of strings. For example, to transform all the lowercase letters in the response body, we can just write:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n     <span class=\"pl-k\">proxy_pass</span> http://mybackend;\n     <span class=\"pl-k\">body_filter_by_lua</span> <span class=\"pl-s\">&apos;ngx.arg[1] = string.upper(ngx.arg[1])&apos;</span>;\n }</pre></div><p>When setting <code>nil</code> or an empty Lua string value to <code>ngx.arg[1]</code>, no data chunk will be passed to the downstream Nginx output filters at all.</p><p>Likewise, new &quot;eof&quot; flag can also be specified by setting a boolean value to <a href=\"#ngxarg\">ngx.arg</a>[2]. For example,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/t </span>{\n     <span class=\"pl-k\">echo</span> hello world;\n     <span class=\"pl-k\">echo</span> hiya globe;\n\n     <span class=\"pl-k\">body_filter_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">         local chunk = ngx.arg[1]</span>\n<span class=\"pl-s\">         if string.match(chunk, &quot;hello&quot;) then</span>\n<span class=\"pl-s\">             ngx.arg[2] = true  -- new eof</span>\n<span class=\"pl-s\">             return</span>\n<span class=\"pl-s\">         end</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">         -- just throw away any remaining chunk data</span>\n<span class=\"pl-s\">         ngx.arg[1] = nil</span>\n<span class=\"pl-s\">     &apos;</span>;\n }</pre></div><p>Then <code>GET /t</code> will just return the output</p><pre><code>hello world\n</code></pre><p>That is, when the body filter sees a chunk containing the word &quot;hello&quot;, then it will set the &quot;eof&quot; flag to true immediately, resulting in truncated but still valid responses.</p><p>When the Lua code may change the length of the response body, then it is required to always clear out the <code>Content-Length</code> response header (if any) in a header filter to enforce streaming output, as in</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">location</span> <span class=\"pl-en\">/foo </span>{\n     <span class=\"pl-c\"># fastcgi_pass/proxy_pass/...</span>\n\n     <span class=\"pl-k\">header_filter_by_lua_block</span> { ngx.header.content_length = nil }\n     <span class=\"pl-k\">body_filter_by_lua</span> <span class=\"pl-s\">&apos;ngx.arg[1] = string.len(ngx.arg[1]) .. &quot;\\\\n&quot;&apos;</span>;\n }</pre></div><p>Note that the following API functions are currently disabled within this context due to the limitations in NGINX output filter&apos;s current implementation:</p><ul>\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxexit\">ngx.exit</a> and <a href=\"#ngxexec\">ngx.exec</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n</ul><p>Nginx output filters may be called multiple times for a single request because response body may be delivered in chunks. Thus, the Lua code specified by in this directive may also run multiple times in the lifetime of a single HTTP request.</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#body_filter_by_lua",
    "name": "body_filter_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>body_filter_by_lua_block { lua-script-str }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>body_filter_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#body_filter_by_lua\">body_filter_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">body_filter_by_lua_block</span> {\n     <span class=\"pl-k\">local</span> data, eof = ngx.arg[1], ngx.arg[2]\n }</pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#body_filter_by_lua_block",
    "name": "body_filter_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>body_filter_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>body_filter_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#body_filter_by_lua\">body_filter_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#body_filter_by_lua_file",
    "name": "body_filter_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>log_by_lua <lua-script-str></strong></code><br></td></tr><tr><th>Default:</th><td><pre>log_by_lua '';</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p><strong>NOTE</strong> Use of this directive is <em>discouraged</em> following the <code>v0.9.17</code> release. Use the <a href=\"#log_by_lua_block\">log_by_lua_block</a> directive instead.</p><p>Runs the Lua source code inlined as the <code>&lt;lua-script-str&gt;</code> at the <code>log</code> request processing phase. This does not replace the current access logs, but runs before.</p><p>Note that the following API functions are currently disabled within this context:</p><ul>\n<li>Output API functions (e.g., <a href=\"#ngxsay\">ngx.say</a> and <a href=\"#ngxsend_headers\">ngx.send_headers</a>)</li>\n<li>Control API functions (e.g., <a href=\"#ngxexit\">ngx.exit</a>)</li>\n<li>Subrequest API functions (e.g., <a href=\"#ngxlocationcapture\">ngx.location.capture</a> and <a href=\"#ngxlocationcapture_multi\">ngx.location.capture_multi</a>)</li>\n<li>Cosocket API functions (e.g., <a href=\"#ngxsockettcp\">ngx.socket.tcp</a> and <a href=\"#ngxreqsocket\">ngx.req.socket</a>).</li>\n</ul><p>Here is an example of gathering average data for <a href=\"http://nginx.org/en/docs/http/ngx_http_upstream_module.html#var_upstream_response_time\" rel=\"nofollow\">$upstream_response_time</a>:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">lua_shared_dict</span> log_dict <span class=\"pl-c1\">5M</span>;\n\n <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">location</span> <span class=\"pl-en\">/ </span>{\n         <span class=\"pl-k\">proxy_pass</span> http://mybackend;\n\n         <span class=\"pl-k\">log_by_lua</span> <span class=\"pl-s\">&apos;</span>\n<span class=\"pl-s\">             local log_dict = ngx.shared.log_dict</span>\n<span class=\"pl-s\">             local upstream_time = tonumber(ngx.var.upstream_response_time)</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">             local sum = log_dict:get(&quot;upstream_time-sum&quot;) or 0</span>\n<span class=\"pl-s\">             sum = sum + upstream_time</span>\n<span class=\"pl-s\">             log_dict:set(&quot;upstream_time-sum&quot;, sum)</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">             local newval, err = log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span>\n<span class=\"pl-s\">             if not newval and err == &quot;not found&quot; then</span>\n<span class=\"pl-s\">                 log_dict:add(&quot;upstream_time-nb&quot;, 0)</span>\n<span class=\"pl-s\">                 log_dict:incr(&quot;upstream_time-nb&quot;, 1)</span>\n<span class=\"pl-s\">             end</span>\n<span class=\"pl-s\">         &apos;</span>;\n     }\n\n     <span class=\"pl-k\">location</span> <span class=\"pl-en\">= /status </span>{\n         <span class=\"pl-k\">content_by_lua_block</span> {\n             <span class=\"pl-k\">local</span> log_dict = ngx.shared.log_dict\n             <span class=\"pl-k\">local</span> sum = log_dict:get(<span class=\"pl-s\">&quot;upstream_time-sum&quot;</span>)\n             <span class=\"pl-k\">local</span> nb = log_dict:get(<span class=\"pl-s\">&quot;upstream_time-nb&quot;</span>)\n\n             <span class=\"pl-k\">if</span> nb and sum then\n                 ngx.say(&quot;<span class=\"pl-k\">average</span> upstream response time: <span class=\"pl-s\">&quot;, sum / nb,</span>\n<span class=\"pl-s\">                         &quot;</span> (<span class=\"pl-s\">&quot;, nb, &quot;</span> reqs)<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\">             else</span>\n<span class=\"pl-s\">                 ngx.say(&quot;</span>no data yet<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\">             end</span>\n<span class=\"pl-s\">         }</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\"> }</span></pre></div><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#log_by_lua",
    "name": "log_by_lua"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>log_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>log_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Similar to the <a href=\"#log_by_lua\">log_by_lua</a> directive except that this directive inlines\nthe Lua source directly\ninside a pair of curly braces (<code>{}</code>) instead of in an NGINX string literal (which requires\nspecial character escaping).</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">log_by_lua_block</span> {\n     print(&quot;<span class=\"pl-k\">I</span> need no extra escaping here, for example: \\r\\nblah<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\"> }</span></pre></div><p>This directive was first introduced in the <code>v0.9.17</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#log_by_lua_block",
    "name": "log_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>log_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>log_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#log_by_lua\">log_by_lua</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.5.0rc31</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#log_by_lua_file",
    "name": "log_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>balancer_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>balancer_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>upstream</code></br></td></tr></table>",
    "doc": "<p>This directive runs Lua code as an upstream balancer for any upstream entities defined\nby the <code>upstream {}</code> configuration block.</p><p>For instance,</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">upstream</span> <span class=\"pl-en\">foo </span>{\n     <span class=\"pl-k\">server</span> <span class=\"pl-s\">127.0.0.1</span>;\n     <span class=\"pl-k\">balancer_by_lua_block</span> {\n         -- <span class=\"pl-k\">use</span> Lua to do something interesting here\n         -- as <span class=\"pl-s\">a</span> dynamic balancer\n     }\n }\n\n server {\n     location / {\n         proxy_pass http://foo;\n     }\n }</pre></div><p>The resulting Lua load balancer can work with any existing nginx upstream modules\nlike <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html\" rel=\"nofollow\">ngx_proxy</a> and\n<a href=\"http://nginx.org/en/docs/http/ngx_http_fastcgi_module.html\" rel=\"nofollow\">ngx_fastcgi</a>.</p><p>Also, the Lua load balancer can work with the standard upstream connection pool mechanism,\ni.e., the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive\" rel=\"nofollow\">keepalive</a> directive.\nJust ensure that the <a href=\"http://nginx.org/en/docs/http/ngx_http_upstream_module.html#keepalive\" rel=\"nofollow\">keepalive</a> directive\nis used <em>after</em> this <code>balancer_by_lua_block</code> directive in a single <code>upstream {}</code> configuration block.</p><p>The Lua load balancer can totally ignore the list of servers defined in the <code>upstream {}</code> block\nand select peer from a completely dynamic server list (even changing per request) via the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/balancer.md\">ngx.balancer</a> module\nfrom the <a href=\"https://github.com/openresty/lua-resty-core\">lua-resty-core</a> library.</p><p>The Lua code handler registered by this directive might get called more than once in a single\ndownstream request when the nginx upstream mechanism retries the request on conditions\nspecified by directives like the <a href=\"http://nginx.org/en/docs/http/ngx_http_proxy_module.html#proxy_next_upstream\" rel=\"nofollow\">proxy_next_upstream</a>\ndirective.</p><p>This Lua code execution context does not support yielding, so Lua APIs that may yield\n(like cosockets and &quot;light threads&quot;) are disabled in this context. One can usually work\naround this limitation by doing such operations in an earlier phase handler (like\n<a href=\"#access_by_lua\">access_by_lua*</a>) and passing along the result into this context\nvia the <a href=\"#ngxctx\">ngx.ctx</a> table.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#balancer_by_lua_block",
    "name": "balancer_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>balancer_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>balancer_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>upstream</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#balancer_by_lua_block\">balancer_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#balancer_by_lua_file",
    "name": "balancer_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_need_request_body <on|off></strong></code><br></td></tr><tr><th>Default:</th><td><pre>off</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location if</code></br></td></tr></table>",
    "doc": "<p>Determines whether to force the request body data to be read before running rewrite/access/access_by_lua* or not. The Nginx core does not read the client request body by default and if request body data is required, then this directive should be turned <code>on</code> or the <a href=\"#ngxreqread_body\">ngx.req.read_body</a> function should be called within the Lua code.</p><p>To read the request body data within the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body\" rel=\"nofollow\">$request_body</a> variable,\n<a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size\" rel=\"nofollow\">client_body_buffer_size</a> must have the same value as <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size\" rel=\"nofollow\">client_max_body_size</a>. Because when the content length exceeds <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_body_buffer_size\" rel=\"nofollow\">client_body_buffer_size</a> but less than <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#client_max_body_size\" rel=\"nofollow\">client_max_body_size</a>, Nginx will buffer the data into a temporary file on the disk, which will lead to empty value in the <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#var_request_body\" rel=\"nofollow\">$request_body</a> variable.</p><p>If the current location includes <a href=\"#rewrite_by_lua\">rewrite_by_lua*</a> directives,\nthen the request body will be read just before the <a href=\"#rewrite_by_lua\">rewrite_by_lua*</a> code is run (and also at the\n<code>rewrite</code> phase). Similarly, if only <a href=\"#content_by_lua\">content_by_lua</a> is specified,\nthe request body will not be read until the content handler&apos;s Lua code is\nabout to run (i.e., the request body will be read during the content phase).</p><p>It is recommended however, to use the <a href=\"#ngxreqread_body\">ngx.req.read_body</a> and <a href=\"#ngxreqdiscard_body\">ngx.req.discard_body</a> functions for finer control over the request body reading process instead.</p><p>This also applies to <a href=\"#access_by_lua\">access_by_lua*</a>.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_need_request_body",
    "name": "lua_need_request_body"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>ssl_certificate_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_certificate_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>server</code></br></td></tr></table>",
    "doc": "<p>This directive runs user Lua code when NGINX is about to start the SSL handshake for the downstream\nSSL (https) connections.</p><p>It is particularly useful for setting the SSL certificate chain and the corresponding private key on a per-request\nbasis. It is also useful to load such handshake configurations nonblockingly from the remote (for example,\nwith the <a href=\"#ngxsockettcp\">cosocket</a> API). And one can also do per-request OCSP stapling handling in pure\nLua here as well.</p><p>Another typical use case is to do SSL handshake traffic control nonblockingly in this context,\nwith the help of the <a href=\"https://github.com/openresty/lua-resty-limit-traffic\">lua-resty-limit-traffic#readme</a>\nlibrary, for example.</p><p>One can also do interesting things with the SSL handshake requests from the client side, like\nrejecting old SSL clients using the SSLv3 protocol or even below selectively.</p><p>The <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md\">ngx.ssl</a>\nand <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md\">ngx.ocsp</a> Lua modules\nprovided by the <a href=\"https://github.com/openresty/lua-resty-core/#readme\">lua-resty-core</a>\nlibrary are particularly useful in this context. You can use the Lua API offered by these two Lua modules\nto manipulate the SSL certificate chain and private key for the current SSL connection\nbeing initiated.</p><p>This Lua handler does not run at all, however, when NGINX/OpenSSL successfully resumes\nthe SSL session via SSL session IDs or TLS session tickets for the current SSL connection. In\nother words, this Lua handler only runs when NGINX has to initiate a full SSL handshake.</p><p>Below is a trivial example using the\n<a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md\">ngx.ssl</a> module\nat the same time:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">server</span> {\n     <span class=\"pl-k\">listen</span> <span class=\"pl-s\">443</span> ssl;\n     <span class=\"pl-k\">server_name</span>   test.com;\n\n     <span class=\"pl-k\">ssl_certificate_by_lua_block</span> {\n         print(&quot;<span class=\"pl-k\">About</span> to initiate <span class=\"pl-s\">a</span> new SSL handshake!<span class=\"pl-s\">&quot;)</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\"></span>\n<span class=\"pl-s\">     location / {</span>\n<span class=\"pl-s\">         root html;</span>\n<span class=\"pl-s\">     }</span>\n<span class=\"pl-s\"> }</span></pre></div><p>See more complicated examples in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl.md\">ngx.ssl</a>\nand <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ocsp.md\">ngx.ocsp</a>\nLua modules&apos; official documentation.</p><p>Uncaught Lua exceptions in the user Lua code immediately abort the current SSL session, so does the\n<a href=\"#ngxexit\">ngx.exit</a> call with an error code like <code>ngx.ERROR</code>.</p><p>This Lua code execution context <em>does</em> support yielding, so Lua APIs that may yield\n(like cosockets, sleeping, and &quot;light threads&quot;)\nare enabled in this context.</p><p>Note, however, you still need to configure the <a href=\"http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate\" rel=\"nofollow\">ssl_certificate</a> and\n<a href=\"http://nginx.org/en/docs/http/ngx_http_ssl_module.html#ssl_certificate_key\" rel=\"nofollow\">ssl_certificate_key</a>\ndirectives even though you will not use this static certificate and private key at all. This is\nbecause the NGINX core requires their appearance otherwise you are seeing the following error\nwhile starting NGINX:</p><pre><code>nginx: [emerg] no ssl configured for the server\n</code></pre><p>This directive currently requires the following NGINX core patch to work correctly:</p><p><a href=\"http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html\" rel=\"nofollow\">http://mailman.nginx.org/pipermail/nginx-devel/2016-January/007748.html</a></p><p>The bundled version of the NGINX core in OpenResty 1.9.7.2 (or above) already has this\npatch applied.</p><p>Furthermore, one needs at least OpenSSL 1.0.2e for this directive to work.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_block",
    "name": "ssl_certificate_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>ssl_certificate_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_certificate_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>server</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or, as from the <code>v0.5.0rc32</code> release, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.0</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#ssl_certificate_by_lua_file",
    "name": "ssl_certificate_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_fetch_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_fetch_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>This directive runs Lua code to look up and load the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream.</p><p>The Lua API for obtaining the current session ID and loading a cached SSL session data\nis provided in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md\">ngx.ssl.session</a>\nLua module shipped with the <a href=\"https://github.com/openresty/lua-resty-core#readme\">lua-resty-core</a>\nlibrary.</p><p>Lua APIs that may yield, like <a href=\"#ngxsleep\">ngx.sleep</a> and <a href=\"#ngxsockettcp\">cosockets</a>,\nare enabled in this context.</p><p>This hook, together with the <a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua*</a> hook,\ncan be used to implement distributed caching mechanisms in pure Lua (based\non the <a href=\"#ngxsockettcp\">cosocket</a> API, for example). If a cached SSL session is found\nand loaded into the current SSL connection context,\nSSL session resumption can then get immediately initiated and bypass the full SSL handshake process which is very expensive in terms of CPU time.</p><p>Please note that TLS session tickets are very different and it is the clients&apos; responsibility\nto cache the SSL session state when session tickets are used. SSL session resumptions based on\nTLS session tickets would happen automatically without going through this hook (nor the\n<a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua*</a> hook). This hook is mainly\nfor older or less capable SSL clients that can only do SSL sessions by session IDs.</p><p>When <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua*</a> is specified at the same time,\nthis hook usually runs before <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua*</a>.\nWhen the SSL session is found and successfully loaded for the current SSL connection,\nSSL session resumption will happen and thus bypass the <a href=\"#ssl_certificate_by_lua_block\">ssl_certificate_by_lua*</a>\nhook completely. In this case, NGINX also bypasses the <a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua*</a>\nhook, for obvious reasons.</p><p>To easily test this hook locally with a modern web browser, you can temporarily put the following line\nin your https server block to disable the TLS session ticket support:</p><pre><code>ssl_session_tickets off;\n</code></pre><p>But do not forget to comment this line out before publishing your site to the world.</p><p>If you are using the <a href=\"http://openresty.org/en/linux-packages.html\" rel=\"nofollow\">official pre-built packages</a> for <a href=\"https://openresty.org/\" rel=\"nofollow\">OpenResty</a>\n1.11.2.1 or later, then everything should work out of the box.</p><p>If you are using OpenSSL libraries not provided by <a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a>,\nthen you need to apply the following patch for OpenSSL 1.0.2h or later:</p><p><a href=\"https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch\">https://github.com/openresty/openresty/blob/master/patches/openssl-1.0.2h-sess_set_get_cb_yield.patch</a></p><p>If you are not using the NGINX core shipped with <a href=\"https://openresty.org\" rel=\"nofollow\">OpenResty</a> 1.11.2.1 or later, then you need to\napply the following patch to the standard NGINX core 1.11.2 or later:</p><p><a href=\"http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch\" rel=\"nofollow\">http://openresty.org/download/nginx-1.11.2-nonblocking_ssl_handshake_hooks.patch</a></p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#ssl_session_fetch_by_lua_block",
    "name": "ssl_session_fetch_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_fetch_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_fetch_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#ssl_session_fetch_by_lua_block\">ssl_session_fetch_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#ssl_session_fetch_by_lua_file",
    "name": "ssl_session_fetch_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_store_by_lua_block { lua-script }</strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_store_by_lua_block {};</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>This directive runs Lua code to fetch and save the SSL session (if any) according to the session ID\nprovided by the current SSL handshake request for the downstream. The saved or cached SSL\nsession data can be used for future SSL connections to resume SSL sessions without going\nthrough the full SSL handshake process (which is very expensive in terms of CPU time).</p><p>Lua APIs that may yield, like <a href=\"#ngxsleep\">ngx.sleep</a> and <a href=\"#ngxsockettcp\">cosockets</a>,\nare <em>disabled</em> in this context. You can still, however, use the <a href=\"#ngxtimerat\">ngx.timer.at</a> API\nto create 0-delay timers to save the SSL session data asynchronously to external services (like <code>redis</code> or <code>memcached</code>).</p><p>The Lua API for obtaining the current session ID and the associated session state data\nis provided in the <a href=\"https://github.com/openresty/lua-resty-core/blob/master/lib/ngx/ssl/session.md#readme\">ngx.ssl.session</a>\nLua module shipped with the <a href=\"https://github.com/openresty/lua-resty-core#readme\">lua-resty-core</a>\nlibrary.</p><p>To easily test this hook locally with a modern web browser, you can temporarily put the following line\nin your https server block to disable the TLS session ticket support:</p><pre><code>ssl_session_tickets off;\n</code></pre><p>But do not forget to comment this line out before publishing your site to the world.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_block",
    "name": "ssl_session_store_by_lua_block"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>ssl_session_store_by_lua_file <path-to-lua-script-file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>ssl_session_store_by_lua_file .lua;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Equivalent to <a href=\"#ssl_session_store_by_lua_block\">ssl_session_store_by_lua_block</a>, except that the file specified by <code>&lt;path-to-lua-script-file&gt;</code> contains the Lua code, or rather, the <a href=\"#lualuajit-bytecode-support\">Lua/LuaJIT bytecode</a> to be executed.</p><p>When a relative path like <code>foo/bar.lua</code> is given, they will be turned into the absolute path relative to the <code>server prefix</code> path determined by the <code>-p PATH</code> command-line option while starting the Nginx server.</p><p>This directive was first introduced in the <code>v0.10.6</code> release.</p><p>Note that: this directive is only allowed to used in <strong>http context</strong> from the <code>v0.10.7</code> release\n(because SSL session resumption happens before server name dispatch).</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#ssl_session_store_by_lua_file",
    "name": "ssl_session_store_by_lua_file"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_shared_dict <name> <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_shared_dict ;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Declares a shared memory zone, <code>&lt;name&gt;</code>, to serve as storage for the shm based Lua dictionary <code>ngx.shared.&lt;name&gt;</code>.</p><p>Shared memory zones are always shared by all the nginx worker processes in the current nginx server instance.</p><p>The <code>&lt;size&gt;</code> argument accepts size units such as <code>k</code> and <code>m</code>:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">http</span> {\n     <span class=\"pl-k\">lua_shared_dict</span> dogs <span class=\"pl-c1\">10m</span>;\n     ...\n }</pre></div><p>The hard-coded minimum size is 8KB while the practical minimum size depends\non actual user data set (some people start with 12KB).</p><p>See <a href=\"#ngxshareddict\">ngx.shared.DICT</a> for details.</p><p>This directive was first introduced in the <code>v0.3.1rc22</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_shared_dict",
    "name": "lua_shared_dict"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_connect_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_connect_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>This directive controls the default timeout value used in TCP/unix-domain socket object&apos;s <a href=\"#tcpsockconnect\">connect</a> method and can be overridden by the <a href=\"#tcpsocksettimeout\">settimeout</a> or <a href=\"#tcpsocksettimeouts\">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., &quot;second&quot;. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_connect_timeout",
    "name": "lua_socket_connect_timeout"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_send_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_send_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Controls the default timeout value used in TCP/unix-domain socket object&apos;s <a href=\"#tcpsocksend\">send</a> method and can be overridden by the <a href=\"#tcpsocksettimeout\">settimeout</a> or <a href=\"#tcpsocksettimeouts\">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., &quot;second&quot;. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_send_timeout",
    "name": "lua_socket_send_timeout"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_send_lowat <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_send_lowat 0</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Controls the <code>lowat</code> (low water) value for the cosocket send buffer.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_send_lowat",
    "name": "lua_socket_send_lowat"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_read_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_read_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>This directive controls the default timeout value used in TCP/unix-domain socket object&apos;s <a href=\"#tcpsockreceive\">receive</a> method and iterator functions returned by the <a href=\"#tcpsockreceiveuntil\">receiveuntil</a> method. This setting can be overridden by the <a href=\"#tcpsocksettimeout\">settimeout</a> or <a href=\"#tcpsocksettimeouts\">settimeouts</a> methods.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., &quot;second&quot;. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_read_timeout",
    "name": "lua_socket_read_timeout"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_buffer_size <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_buffer_size 4k/8k</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Specifies the buffer size used by cosocket reading operations.</p><p>This buffer does not have to be that big to hold everything at the same time because cosocket supports 100% non-buffered reading and parsing. So even <code>1</code> byte buffer size should still work everywhere but the performance could be terrible.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_buffer_size",
    "name": "lua_socket_buffer_size"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_pool_size <size></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_pool_size 30</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Specifies the size limit (in terms of connection count) for every cosocket connection pool associated with every remote server (i.e., identified by either the host-port pair or the unix domain socket file path).</p><p>Default to 30 connections for every pool.</p><p>When the connection pool exceeds the available size limit, the least recently used (idle) connection already in the pool will be closed to make room for the current connection.</p><p>Note that the cosocket connection pool is per nginx worker process rather than per nginx server instance, so size limit specified here also applies to every single nginx worker process.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_pool_size",
    "name": "lua_socket_pool_size"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_keepalive_timeout <time></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_keepalive_timeout 60s</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>This directive controls the default maximal idle time of the connections in the cosocket built-in connection pool. When this timeout reaches, idle connections will be closed and removed from the pool. This setting can be overridden by cosocket objects&apos; <a href=\"#tcpsocksetkeepalive\">setkeepalive</a> method.</p><p>The <code>&lt;time&gt;</code> argument can be an integer, with an optional time unit, like <code>s</code> (second), <code>ms</code> (millisecond), <code>m</code> (minute). The default time unit is <code>s</code>, i.e., &quot;second&quot;. The default setting is <code>60s</code>.</p><p>This directive was first introduced in the <code>v0.5.0rc1</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_keepalive_timeout",
    "name": "lua_socket_keepalive_timeout"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_socket_log_errors on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_socket_log_errors on</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>This directive can be used to toggle error logging when a failure occurs for the TCP or UDP cosockets. If you are already doing proper error handling and logging in your Lua code, then it is recommended to turn this directive off to prevent data flushing in your nginx error log files (which is usually rather expensive).</p><p>This directive was first introduced in the <code>v0.5.13</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_socket_log_errors",
    "name": "lua_socket_log_errors"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_ciphers <ciphers></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_ciphers DEFAULT</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Specifies the enabled ciphers for requests to a SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method. The ciphers are specified in the format understood by the OpenSSL library.</p><p>The full list can be viewed using the &#x201C;openssl ciphers&#x201D; command.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_ssl_ciphers",
    "name": "lua_ssl_ciphers"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_crl <file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_crl ;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Specifies a file with revoked certificates (CRL) in the PEM format used to verify the certificate of the SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_ssl_crl",
    "name": "lua_ssl_crl"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_protocols [SSLv2] [SSLv3] [TLSv1] [TLSv1.1] [TLSv1.2] [TLSv1.3]</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Enables the specified protocols for requests to a SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method.</p><p>The support for the <code>TLSv1.3</code> parameter requires version <code>v0.10.12</code> <em>and</em> OpenSSL 1.1.1.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_ssl_protocols",
    "name": "lua_ssl_protocols"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_trusted_certificate <file></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_trusted_certificate ;</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Specifies a file path with trusted CA certificates in the PEM format used to verify the certificate of the SSL/TLS server in the <a href=\"#tcpsocksslhandshake\">tcpsock:sslhandshake</a> method.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><p>See also <a href=\"#lua_ssl_verify_depth\">lua_ssl_verify_depth</a>.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_ssl_trusted_certificate",
    "name": "lua_ssl_trusted_certificate"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_ssl_verify_depth <number></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_ssl_verify_depth 1</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br></td></tr></table>",
    "doc": "<p>Sets the verification depth in the server certificates chain.</p><p>This directive was first introduced in the <code>v0.9.11</code> release.</p><p>See also <a href=\"#lua_ssl_trusted_certificate\">lua_ssl_trusted_certificate</a>.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_ssl_verify_depth",
    "name": "lua_ssl_verify_depth"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_http10_buffering on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_http10_buffering on</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location-if</code></br></td></tr></table>",
    "doc": "<p>Enables or disables automatic response buffering for HTTP 1.0 (or older) requests. This buffering mechanism is mainly used for HTTP 1.0 keep-alive which relies on a proper <code>Content-Length</code> response header.</p><p>If the Lua code explicitly sets a <code>Content-Length</code> response header before sending the headers (either explicitly via <a href=\"#ngxsend_headers\">ngx.send_headers</a> or implicitly via the first <a href=\"#ngxsay\">ngx.say</a> or <a href=\"#ngxprint\">ngx.print</a> call), then the HTTP 1.0 response buffering will be disabled even when this directive is turned on.</p><p>To output very large response data in a streaming fashion (via the <a href=\"#ngxflush\">ngx.flush</a> call, for example), this directive MUST be turned off to minimize memory usage.</p><p>This directive is turned <code>on</code> by default.</p><p>This directive was first introduced in the <code>v0.5.0rc19</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_http10_buffering",
    "name": "lua_http10_buffering"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>rewrite_by_lua_no_postpone on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>rewrite_by_lua_no_postpone off</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Controls whether or not to disable postponing <a href=\"#rewrite_by_lua\">rewrite_by_lua*</a> directives to run at the end of the <code>rewrite</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>rewrite</code> phase.</p><p>This directive was first introduced in the <code>v0.5.0rc29</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#rewrite_by_lua_no_postpone",
    "name": "rewrite_by_lua_no_postpone"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>access_by_lua_no_postpone on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>access_by_lua_no_postpone off</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Controls whether or not to disable postponing <a href=\"#access_by_lua\">access_by_lua*</a> directives to run at the end of the <code>access</code> request-processing phase. By default, this directive is turned off and the Lua code is postponed to run at the end of the <code>access</code> phase.</p><p>This directive was first introduced in the <code>v0.9.20</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#access_by_lua_no_postpone",
    "name": "access_by_lua_no_postpone"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_transform_underscores_in_response_headers on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_transform_underscores_in_response_headers on</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location-if</code></br></td></tr></table>",
    "doc": "<p>Controls whether to transform underscores (<code>_</code>) in the response header names specified in the <a href=\"#ngxheaderheader\">ngx.header.HEADER</a> API to hypens (<code>-</code>).</p><p>This directive was first introduced in the <code>v0.5.0rc32</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_transform_underscores_in_response_headers",
    "name": "lua_transform_underscores_in_response_headers"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_check_client_abort on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_check_client_abort off</pre></td></tr><tr><th>Context:</th><td><code>http</code></br><code>server</code></br><code>location</code></br><code>location-if</code></br></td></tr></table>",
    "doc": "<p>This directive controls whether to check for premature client connection abortion.</p><p>When this directive is on, the ngx_lua module will monitor the premature connection close event on the downstream connections and when there is such an event, it will call the user Lua function callback (registered by <a href=\"#ngxon_abort\">ngx.on_abort</a>) or just stop and clean up all the Lua &quot;light threads&quot; running in the current request&apos;s request handler when there is no user callback function registered.</p><p>According to the current implementation, however, if the client closes the connection before the Lua code finishes reading the request body data via <a href=\"#ngxreqsocket\">ngx.req.socket</a>, then ngx_lua will neither stop all the running &quot;light threads&quot; nor call the user callback (if <a href=\"#ngxon_abort\">ngx.on_abort</a> has been called). Instead, the reading operation on <a href=\"#ngxreqsocket\">ngx.req.socket</a> will just return the error message &quot;client aborted&quot; as the second return value (the first return value is surely <code>nil</code>).</p><p>When TCP keepalive is disabled, it is relying on the client side to close the socket gracefully (by sending a <code>FIN</code> packet or something like that). For (soft) real-time web applications, it is highly recommended to configure the <a href=\"http://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html\" rel=\"nofollow\">TCP keepalive</a> support in your system&apos;s TCP stack implementation in order to detect &quot;half-open&quot; TCP connections in time.</p><p>For example, on Linux, you can configure the standard <a href=\"http://nginx.org/en/docs/http/ngx_http_core_module.html#listen\" rel=\"nofollow\">listen</a> directive in your <code>nginx.conf</code> file like this:</p><div class=\"highlight highlight-source-nginx\"><pre> <span class=\"pl-k\">listen</span> <span class=\"pl-s\">80</span> so_keepalive=2s:2s:8;</pre></div><p>On FreeBSD, you can only tune the system-wide configuration for TCP keepalive, for example:</p><pre><code># sysctl net.inet.tcp.keepintvl=2000\n# sysctl net.inet.tcp.keepidle=2000\n</code></pre><p>This directive was first introduced in the <code>v0.7.4</code> release.</p><p>See also <a href=\"#ngxon_abort\">ngx.on_abort</a>.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_check_client_abort",
    "name": "lua_check_client_abort"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_max_pending_timers <count></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_max_pending_timers 1024</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Controls the maximum number of pending timers allowed.</p><p>Pending timers are those timers that have not expired yet.</p><p>When exceeding this limit, the <a href=\"#ngxtimerat\">ngx.timer.at</a> call will immediately return <code>nil</code> and the error string &quot;too many pending timers&quot;.</p><p>This directive was first introduced in the <code>v0.8.0</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_max_pending_timers",
    "name": "lua_max_pending_timers"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_max_running_timers <count></strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_max_running_timers 256</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>Controls the maximum number of &quot;running timers&quot; allowed.</p><p>Running timers are those timers whose user callback functions are still running.</p><p>When exceeding this limit, Nginx will stop running the callbacks of newly expired timers and log an error message &quot;N lua_max_running_timers are not enough&quot; where &quot;N&quot; is the current value of this directive.</p><p>This directive was first introduced in the <code>v0.8.0</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_max_running_timers",
    "name": "lua_max_running_timers"
  },
  {
    "table": "<table ><tr><th>Syntax:</th><td><code><strong>lua_sa_restart on|off</strong></code><br></td></tr><tr><th>Default:</th><td><pre>lua_sa_restart on</pre></td></tr><tr><th>Context:</th><td><code>http</code></br></td></tr></table>",
    "doc": "<p>When enabled, this module will set the <code>SA_RESTART</code> flag on nginx workers signal dispositions.</p><p>This allows Lua I/O primitives to not be interrupted by nginx&apos;s handling of various signals.</p><p>This directive was first introduced in the <code>v0.10.14</code> release.</p>",
    "module": "lua-nginx-module",
    "link": "https://github.com/openresty/lua-nginx-module#lua_sa_restart",
    "name": "lua_sa_restart"
  }
]
